"""
DataModule for PDE Discovery from Spatiotemporal Imaging Data

Extends the existing datamodule structure to support chemotaxis problems.
"""

import numpy as np
from typing import Dict, Optional, Tuple
from dataclasses import dataclass
from pathlib import Path
import h5py

from bench.dataclasses import Problem, Equation, SEDTask
from bench.pde_solver import PDESolver, PDEConfig, create_chemotaxis_datamodule


@dataclass
class ChemotaxisProblem:
    """
    Problem definition for chemotaxis PDE discovery

    Attributes:
        g_init: Initial cell density field (H, W)
        S: Chemoattractant field (H, W) or (H, W, T)
        g_observed: Observed cell density evolution (H, W, T)
        metadata: Additional metadata
        gt_equation: Ground truth equation (if available)
    """
    g_init: np.ndarray
    S: np.ndarray
    g_observed: np.ndarray
    metadata: Dict
    gt_equation: Optional[str] = None

    def to_sed_task(self, task_name: str = "Chemotaxis PDE Discovery") -> SEDTask:
        """
        Convert to SEDTask format for compatibility with existing pipeline

        Returns:
            SEDTask instance
        """
        H, W, T = self.g_observed.shape

        # Define symbols
        symbols = ['g', 'S', 'x', 'y', 't']

        symbol_descs = {
            'g': 'Cell density field (neutrophils)',
            'S': 'Chemoattractant field (LTB4/Ca²⁺ staining)',
            'x': 'Spatial coordinate (horizontal)',
            'y': 'Spatial coordinate (vertical)',
            't': 'Time coordinate'
        }

        symbol_properties = {
            'g': f'Shape: ({H}, {W}, {T}), Range: [{self.g_observed.min():.4f}, {self.g_observed.max():.4f}]',
            'S': f'Shape: {self.S.shape}, Range: [{self.S.min():.4f}, {self.S.max():.4f}]',
            'x': f'Range: [0, {W-1}], Step: {self.metadata.get("dx", 1.0)}',
            'y': f'Range: [0, {H-1}], Step: {self.metadata.get("dy", 1.0)}',
            't': f'Range: [0, {T-1}], Step: {self.metadata.get("dt", 0.01)}'
        }

        # Problem description
        desc = f"""Discover a PDE that describes neutrophil chemotaxis from spatiotemporal imaging data.

Input: Cell density field g(x,y,t) with shape {self.g_observed.shape}
Output: Chemoattractant field S(x,y,t)

Physical Context: Neutrophils migrate toward chemoattractant gradients (chemotaxis)
while undergoing random diffusion.

Expected PDE form: ∂g/∂t = f(g, S, ∇g, ∇S, Δg, ...)

Reference Model: {self.gt_equation if self.gt_equation else 'Unknown'}
"""

        # Package samples
        samples = {
            'g_init': self.g_init,
            'S': self.S,
            'g_observed': self.g_observed,
            'metadata': self.metadata
        }

        return SEDTask(
            name=task_name,
            symbols=symbols,
            symbol_descs=symbol_descs,
            symbol_properties=symbol_properties,
            samples=samples,
            desc=desc
        )


class ChemotaxisDataModule:
    """
    DataModule for loading and managing chemotaxis datasets

    Can load from:
    1. Synthetic data generated by reference PDE
    2. HDF5 files with experimental data
    3. Custom numpy arrays
    """

    def __init__(self, data_source: str = "synthetic", data_path: Optional[str] = None):
        """
        Initialize datamodule

        Args:
            data_source: 'synthetic', 'hdf5', or 'numpy'
            data_path: Path to data file (for hdf5/numpy sources)
        """
        self.data_source = data_source
        self.data_path = data_path
        self.problems: Dict[str, ChemotaxisProblem] = {}

    def load(self) -> Dict[str, ChemotaxisProblem]:
        """
        Load dataset

        Returns:
            Dictionary mapping problem IDs to ChemotaxisProblem instances
        """
        if self.data_source == "synthetic":
            return self._load_synthetic()
        elif self.data_source == "hdf5":
            return self._load_hdf5()
        elif self.data_source == "numpy":
            return self._load_numpy()
        else:
            raise ValueError(f"Unknown data source: {self.data_source}")

    def _load_synthetic(self) -> Dict[str, ChemotaxisProblem]:
        """Generate synthetic chemotaxis data"""
        data = create_chemotaxis_datamodule()

        problem = ChemotaxisProblem(
            g_init=data['g_init'],
            S=data['S'],
            g_observed=data['g_observed'],
            metadata=data['metadata'],
            gt_equation=data['metadata']['reference_pde']
        )

        self.problems = {'synthetic_001': problem}
        return self.problems

    def _load_hdf5(self) -> Dict[str, ChemotaxisProblem]:
        """Load from HDF5 file"""
        if not self.data_path:
            raise ValueError("data_path required for HDF5 source")

        problems = {}

        with h5py.File(self.data_path, 'r') as f:
            for problem_id in f.keys():
                grp = f[problem_id]

                problem = ChemotaxisProblem(
                    g_init=grp['g_init'][:],
                    S=grp['S'][:],
                    g_observed=grp['g_observed'][:],
                    metadata=dict(grp.attrs),
                    gt_equation=grp.attrs.get('gt_equation', None)
                )

                problems[problem_id] = problem

        self.problems = problems
        return problems

    def _load_numpy(self) -> Dict[str, ChemotaxisProblem]:
        """Load from numpy .npz file"""
        if not self.data_path:
            raise ValueError("data_path required for numpy source")

        data = np.load(self.data_path, allow_pickle=True)

        problem = ChemotaxisProblem(
            g_init=data['g_init'],
            S=data['S'],
            g_observed=data['g_observed'],
            metadata=data.get('metadata', {}).item() if 'metadata' in data else {},
            gt_equation=data.get('gt_equation', None).item() if 'gt_equation' in data else None
        )

        self.problems = {'numpy_001': problem}
        return problems

    def save_hdf5(self, output_path: str):
        """
        Save problems to HDF5 file

        Args:
            output_path: Path to output HDF5 file
        """
        with h5py.File(output_path, 'w') as f:
            for problem_id, problem in self.problems.items():
                grp = f.create_group(problem_id)

                grp.create_dataset('g_init', data=problem.g_init)
                grp.create_dataset('S', data=problem.S)
                grp.create_dataset('g_observed', data=problem.g_observed)

                for key, val in problem.metadata.items():
                    grp.attrs[key] = val

                if problem.gt_equation:
                    grp.attrs['gt_equation'] = problem.gt_equation

    def save_numpy(self, output_path: str, problem_id: str = None):
        """
        Save single problem to numpy .npz file

        Args:
            output_path: Path to output .npz file
            problem_id: Which problem to save (default: first)
        """
        if problem_id is None:
            problem_id = list(self.problems.keys())[0]

        problem = self.problems[problem_id]

        np.savez(
            output_path,
            g_init=problem.g_init,
            S=problem.S,
            g_observed=problem.g_observed,
            metadata=np.array(problem.metadata, dtype=object),
            gt_equation=np.array(problem.gt_equation, dtype=object) if problem.gt_equation else None
        )

    def get_problem(self, problem_id: str) -> ChemotaxisProblem:
        """Get specific problem by ID"""
        return self.problems.get(problem_id)

    def get_all_problems(self) -> Dict[str, ChemotaxisProblem]:
        """Get all problems"""
        return self.problems

    def __len__(self) -> int:
        """Number of problems"""
        return len(self.problems)

    def __repr__(self) -> str:
        return f"ChemotaxisDataModule(source={self.data_source}, n_problems={len(self)})"


def create_test_dataset(output_dir: str = "./test_data"):
    """
    Create a small test dataset for development

    Args:
        output_dir: Directory to save test data
    """
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    # Generate synthetic data with varying parameters
    solver = PDESolver(PDEConfig(dx=1.0, dy=1.0, dt=0.01))

    test_cases = [
        {'alpha': 0.5, 'name': 'balanced'},
        {'alpha': 0.1, 'name': 'chemotaxis_dominated'},
        {'alpha': 2.0, 'name': 'diffusion_dominated'}
    ]

    datamodule = ChemotaxisDataModule(data_source="synthetic")

    for case in test_cases:
        # Generate data
        H, W = 64, 64  # Smaller for testing
        T = 50

        x = np.linspace(0, H-1, H)
        y = np.linspace(0, W-1, W)
        X, Y = np.meshgrid(x, y)

        # Initial condition
        g_init = np.exp(-((X - H/2)**2 + (Y - W/2)**2) / (0.1 * H**2))

        # Chemoattractant field
        S = np.exp(0.01 * X + 0.01 * Y)

        # Solve with specific alpha
        g_observed = solver.solve_reference_pde(g_init, S, case['alpha'], num_steps=T)

        # Save
        problem = ChemotaxisProblem(
            g_init=g_init,
            S=S,
            g_observed=g_observed,
            metadata={
                'alpha_true': case['alpha'],
                'name': case['name'],
                'H': H, 'W': W, 'T': T,
                'dx': 1.0, 'dy': 1.0, 'dt': 0.01,
                'reference_pde': '∇·(g∇(ln S)) = α·Δg - ∂g/∂t'
            },
            gt_equation='∂g/∂t = α·Δg - ∇·(g∇(ln S))'
        )

        datamodule.problems[f'test_{case["name"]}'] = problem

    # Save as HDF5
    hdf5_path = output_path / "chemotaxis_test.hdf5"
    datamodule.save_hdf5(str(hdf5_path))

    print(f"Test dataset created at {hdf5_path}")
    print(f"Contains {len(datamodule)} problems")

    return str(hdf5_path)


if __name__ == "__main__":
    # Create test dataset when run directly
    create_test_dataset()
